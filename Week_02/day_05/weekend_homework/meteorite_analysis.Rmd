---
title: "meteorite_analysis"
output: html_document
---

Loading the Cleaned data in to R
```{r}
meteorite_clean
```

The names and years found for the 10 largest meteorites in the Data set.

```{r}
meteorite_clean %>% 
  select(name, year, mass_g) %>% 
  arrange(desc(mass_g)) %>% 
  head(10)

```

The average mass of meteorites that were recorded falling, vs. those which were just found.

```{r}
avg_mass_fell <- meteorite_clean %>% 
  filter(fall == "Fell") %>% 
  summarise(mean(mass_g, na.rm = T)) %>% 
  pull()


avg_mass_found <- meteorite_clean %>% 
  filter(fall == "Found") %>% 
  summarise(mean(mass_g, na.rm = T)) %>% 
  pull()

list ("avg_mass_fell" = avg_mass_fell, "avg_mass_found" = avg_mass_found)

```

The number of meteorites in each year, for every year since 2000.

```{r}
meteorite_clean %>% 
  filter(year >= 2000) %>% 
  group_by(year) %>% 
  summarise(numer_of_meteorite = n())


```

A function called get_meteorite_count() that takes in two arguments: a dataframe and a year, and returns the phrase ‚ÄúIn (input_year), there were (number of meteorites that year) meteorites.‚Äù IF there are 1 or more meteorites that year. If there are no meteorites in the year, return the phrase ‚ÄúAs far as we know, there were no meteorites that year‚Äù.

```{r}

get_meteorite_count <- function(d, y){
  
  # Pull the number of meteorites
  
  number_of_meteorites <- meteorite_clean %>%
    filter (year == y) %>% 
    summarise(n()) %>% 
    pull()

  # Check if the number of meteorites is greater than or equal to 1 and print out the required results
  
  if (number_of_meteorites >= 1) {
   return(str_c("In ", y, ", there were ", number_of_meteorites, " meteorites"))
  }else {
    return("As far as we know, there were no meteorites that year")
  }
}

```

```{r}

get_meteorite_count(meteorite_clean, 2000)
```
Test Plans

We can test if the fuction takes in only a numeric input or if still returs a result even for numeric inputs.

I was thinking of having the function look for the max and min years for the entered Data set and esuring the entered value is within these years. This would prevent the fuction from generating results for years that are not in the data set.



A unit test for your function to check whether non-numeric inputs (character and logical) for the year argument return an error.

```{r}

library (testthat)

test_that("Test meteorite count function handling of non-numeric inputs",{
          expect_error(get_meteorite_count(meteorite_clean, "hi"))
          expect_error(get_meteorite_count(meteorite_clean, T))
          expect_error(get_meteorite_count(meteorite_clean, F))
          })
```

An Improved function based on the result of the test. Instead of going back and changing the function, I have create a new function that is the improved version called refactor_get_meteorite_count(). Test the function to make sure it now gives an error when you input a logical or character value as the year.

```{r}
refactor_get_meteorite_count <- function(d, y){
  
  # condition that makes sure the function takes only a numeric input
  
  if (!is.numeric(year)){
    stop("Non-numeric input üòø")
  }
  # Pull the number of meteorites
  
  number_of_meteorites <- meteorite_clean %>%
    filter (year == y) %>% 
    summarise(n()) %>% 
    pull()

  # Check if the number of meteorites is greater than or equal to 1 and print out the required results
  
  if (number_of_meteorites >= 1) {
   return(str_c("In ", y, ", there were ", number_of_meteorites, " meteorites"))
  }else {
    return("As far as we know, there were no meteorites that year")
  }
}
```

Unit testing the new function

```{r}

test_that("Test refactor meteorite count function handling of non-numeric inputs",{
          expect_error(refactor_get_meteorite_count(meteorite_clean, "hi"))
          expect_error(refactor_get_meteorite_count(meteorite_clean, T))
          expect_error(refactor_get_meteorite_count(meteorite_clean, F))
          })

```

